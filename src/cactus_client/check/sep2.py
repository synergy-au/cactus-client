import re
from typing import Callable, cast

from cactus_test_definitions.csipaus import CSIPAusResource
from envoy_schema.server.schema.sep2.der import DERControlResponse
from envoy_schema.server.schema.sep2.der_control_types import ActivePower, ReactivePower

from cactus_client.model.resource import (
    StoredResource,
)

CLIENT_CONTROLLED_MRIDS: set[CSIPAusResource] = {
    CSIPAusResource.MirrorUsagePoint,
}  # These resource types have their mrid managed by the client. Other resources have their mrids generated by the server


def is_invalid_mrid(mrid: str | None, expected_pen: int) -> str | None:
    """Is this mrid well formed and has the CSIP-Aus requirements of a PEN encoded in the last 10 digits? Returns
    a short (human readable) descriptor of the error or returns None if valid."""

    if not mrid:
        return "No value was found (empty/None string)."

    if re.search(r"[^A-Z0-9]", mrid):
        return "Only uppercase, hexadecimal characters should be encoded."

    if len(mrid) > 32:
        return "Must be contain at most 32 characters."

    if (len(mrid) % 2) != 0:
        return "Must be an even number of hexadecimal characters."

    try:
        pen_from_mrid = int(mrid[-8:])
    except ValueError:
        return f"The last 8 digits don't encode a base10 integer '{mrid[-8:]}'"

    if pen_from_mrid != expected_pen:
        return f"Mismatch on PEN. Found {pen_from_mrid} but expected {expected_pen}"

    return None


def is_invalid_power_type(entity: ActivePower | ReactivePower | None) -> str | None:
    if entity is None:
        return None

    if not isinstance(entity.multiplier, int):
        return f"multiplier should be an integer (got {type(entity.multiplier)} {entity.multiplier})"

    if not isinstance(entity.value, int):
        return f"value should be an integer (got {type(entity.value)} {entity.value})"

    max_value = 2**15 - 1  # Int16 max
    min_value = -(2**15)  # Int16 min

    if entity.value < min_value or entity.value > max_value:
        return f"value {entity.value} is out of range - expected [{min_value}, {max_value}]"

    return None


def is_invalid_signed_percent(signed_percent: int | None) -> str | None:
    if signed_percent is None:
        return None

    if not isinstance(signed_percent, int):
        return f"SignedPerCent should be an integer (got {type(signed_percent)} {signed_percent})"

    if signed_percent < -10000 or signed_percent > 10000:
        return f"SignedPerCent should be hundredths of a percent. {signed_percent} is out of range [-10000, 10000]"

    return None


def first_invalid_value(*validators: Callable[[], tuple[str, str | None]]) -> str | None:
    """Convenience function - executes a number of validation lambdas and returns the first one that fails

    Each validator function should return a label and error message in a tuple"""
    for v in validators:
        label, error = v()
        if error:
            return f"{label}: {error}"
    return None


def is_invalid_der_control(derc: DERControlResponse) -> str | None:
    """Returns a short (human readable) error or None if the DERControlResponse is valid"""
    return first_invalid_value(
        lambda: ("opModExpLimW", is_invalid_power_type(derc.DERControlBase_.opModExpLimW)),
        lambda: ("opModImpLimW", is_invalid_power_type(derc.DERControlBase_.opModImpLimW)),
        lambda: ("opModGenLimW", is_invalid_power_type(derc.DERControlBase_.opModGenLimW)),
        lambda: ("opModLoadLimW", is_invalid_power_type(derc.DERControlBase_.opModLoadLimW)),
        lambda: ("opModTargetVar", is_invalid_power_type(derc.DERControlBase_.opModTargetVar)),
        lambda: ("opModTargetW", is_invalid_power_type(derc.DERControlBase_.opModTargetW)),
        lambda: ("opModFixedW", is_invalid_signed_percent(derc.DERControlBase_.opModFixedW)),
    )


def is_invalid_resource(sr: StoredResource, expected_server_pen: int) -> str | None:
    """Does a deep inspection on sr (specifically the underlying CSIP-Aus Resource) looking for "common" failures
    of various forms. eg- having a malformed mrid

    Returns a short (human readable) error or None if the resource is valid"""

    # Validate server generated mrids
    if hasattr(sr.resource, "mRID") and sr.resource_type not in CLIENT_CONTROLLED_MRIDS:
        mrid: str = sr.resource.mRID
        mrid_error = is_invalid_mrid(mrid, expected_server_pen)
        if mrid_error:
            return f"mrid '{mrid}' is invalid: {mrid_error}"

    #
    # This is where we check resource specific things
    #

    # DERControls
    if sr.resource_type == CSIPAusResource.DERControl:
        return is_invalid_der_control(cast(DERControlResponse, sr.resource))

    # Everything is OK
    return None
